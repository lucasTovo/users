import { Ref, ComputedRef, DefineComponent, VNode, RendererNode, RendererElement, ComponentOptionsMixin, VNodeProps, AllowedComponentProps, ComponentCustomProps } from 'vue';

interface ValidationResult {
    errors: string[];
}
declare type MaybeReactive<T> = Ref<T> | ComputedRef<T> | T;
declare type SubmitEvent = Event & {
    target: HTMLFormElement;
};
declare type GenericValidateFunction = (value: any) => boolean | string | Promise<boolean | string>;
interface FormController {
    register(field: any): void;
    unregister(field: any): void;
    values: Record<string, any>;
    fields: ComputedRef<Record<string, any>>;
    schema?: Record<string, GenericValidateFunction | string | Record<string, any>>;
    validateSchema?: (shouldMutate?: boolean) => Promise<Record<string, ValidationResult>>;
    setFieldValue: (path: string, value: any) => void;
    setFieldError: (field: string, message: string) => void;
    setErrors: (fields: Record<string, string>) => void;
    setValues: (fields: Record<string, any>) => void;
}
declare type SubmissionContext = {
    evt: SubmitEvent;
    form: FormController;
};
declare type SubmissionHandler = (values: Record<string, any>, ctx: SubmissionContext) => any;

interface ValidationOptions {
    name?: string;
    values?: Record<string, any>;
    bails?: boolean;
    skipIfEmpty?: boolean;
    isInitial?: boolean;
}
/**
 * Validates a value against the rules.
 */
declare function validate(value: any, rules: string | Record<string, any> | GenericValidateFunction, options?: ValidationOptions): Promise<ValidationResult>;

interface FieldContext {
    field: string;
    value: any;
    form: Record<string, any>;
    rule?: {
        name: string;
        params?: Record<string, any> | any[];
    };
}
declare type ValidationRuleFunction = (value: any, params: any[] | Record<string, any>, ctx: FieldContext) => boolean | string | Promise<boolean | string>;
declare type ValidationMessageGenerator = (ctx: FieldContext) => string;

/**
 * Adds a custom validator to the list of validation rules.
 */
declare function defineRule(id: string, validator: ValidationRuleFunction): void;

interface VeeValidateConfig {
    bails: boolean;
    generateMessage: ValidationMessageGenerator;
    validateOnInput: boolean;
    validateOnChange: boolean;
    validateOnBlur: boolean;
    validateOnModelUpdate: boolean;
}
declare const configure: (newConf: Partial<VeeValidateConfig>) => void;

declare const Field: DefineComponent<{
    as: {
        type: (ObjectConstructor | StringConstructor)[];
        default: any;
    };
    name: {
        type: StringConstructor;
        required: true;
    };
    rules: {
        type: (ObjectConstructor | FunctionConstructor | StringConstructor)[];
        default: any;
    };
    validateOnMount: {
        type: BooleanConstructor;
        default: boolean;
    };
    bails: {
        type: BooleanConstructor;
        default: () => boolean;
    };
    disabled: {
        type: BooleanConstructor;
        default: boolean;
    };
    label: {
        type: StringConstructor;
        default: any;
    };
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}> | VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<{
    disabled: boolean;
    label: string;
    name: string;
    bails: boolean;
    validateOnMount: boolean;
    as: any;
    rules: any;
} & {}>, {
    disabled: boolean;
    label: string;
    bails: boolean;
    validateOnMount: boolean;
    as: any;
    rules: any;
}>;

declare const Form: DefineComponent<{
    as: {
        type: StringConstructor;
        default: string;
    };
    validationSchema: {
        type: ObjectConstructor;
        default: any;
    };
    initialValues: {
        type: ObjectConstructor;
        default: any;
    };
    validateOnMount: {
        type: BooleanConstructor;
        default: boolean;
    };
}, (this: any) => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}> | VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<{
    validateOnMount: boolean;
    as: string;
    validationSchema: Record<string, any>;
    initialValues: Record<string, any>;
} & {}>, {
    validateOnMount: boolean;
    as: string;
    validationSchema: Record<string, any>;
    initialValues: Record<string, any>;
}>;

declare const ErrorMessage: DefineComponent<{
    as: {
        type: StringConstructor;
        default: any;
    };
    name: {
        type: StringConstructor;
        required: true;
    };
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}> | VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<{
    name: string;
    as: string;
} & {}>, {
    as: string;
}>;

interface FieldOptions {
    initialValue: any;
    disabled: MaybeReactive<boolean>;
    validateOnValueUpdate: boolean;
    validateOnMount?: boolean;
    bails?: boolean;
    form?: FormController;
    type?: string;
    valueProp?: MaybeReactive<any>;
    label?: string;
}
declare type RuleExpression = MaybeReactive<string | Record<string, any> | GenericValidateFunction>;
/**
 * Creates a field composite.
 */
declare function useField(name: string, rules: RuleExpression, opts?: Partial<FieldOptions>): {
    name: string;
    value: any;
    meta: {
        untouched: boolean;
        touched: boolean;
        dirty: boolean;
        pristine: boolean;
        valid: boolean;
        invalid: boolean;
        passed: boolean;
        failed: boolean;
        validated: boolean;
        pending: boolean;
        changed: boolean;
    };
    errors: Ref<string[]>;
    errorMessage: ComputedRef<string>;
    aria: ComputedRef<{
        'aria-invalid': string;
        'aria-describedBy': string;
    }>;
    reset: () => void;
    validate: () => Promise<ValidationResult>;
    handleChange: (e: unknown) => Promise<ValidationResult>;
    handleBlur: () => void;
    handleInput: (e: unknown) => void;
    disabled: MaybeReactive<boolean>;
    setValidationState: (result: ValidationResult) => ValidationResult;
    type: string;
    valueProp: any;
    checked: ComputedRef<any>;
    idx: number;
};

interface FormOptions {
    validationSchema?: Record<string, GenericValidateFunction | string | Record<string, any>>;
    initialValues?: MaybeReactive<Record<string, any>>;
    validateOnMount?: boolean;
}
declare function useForm(opts?: FormOptions): {
    errors: ComputedRef<any>;
    meta: ComputedRef<Record<string, boolean>>;
    form: FormController;
    values: {
        [x: string]: any;
    };
    validate: () => Promise<boolean>;
    isSubmitting: Ref<boolean>;
    handleReset: () => void;
    handleSubmit: (fn?: SubmissionHandler) => (e: unknown) => Promise<void>;
    submitForm: (e: unknown) => Promise<void>;
    setFieldError: (field: string, message: string) => void;
    setErrors: (fields: Record<string, string>) => void;
    setFieldValue: (path: string, value: any) => void;
    setValues: (fields: Record<string, any>) => void;
};

export { ErrorMessage, Field, Form, configure, defineRule, useField, useForm, validate };
